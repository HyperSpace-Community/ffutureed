# -------------------- System Libraries --------------------------------
import json
import os
import shutil
from threading import Thread
import sys
import threading
import time
# -------------------- Dynamic Libraries --------------------------------
from langchain import hub
from langchain.agents import AgentType, Tool, initialize_agent
from langchain.memory import ConversationBufferMemory
from langchain_huggingface import HuggingFaceEmbeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain_community.agent_toolkits import GmailToolkit
from langchain_community.tools import WikipediaQueryRun, DuckDuckGoSearchRun
from langchain.prompts import PromptTemplate
from langchain_community.tools.gmail.utils import build_resource_service, get_gmail_credentials
from langchain_community.utilities import WikipediaAPIWrapper
from langchain_chroma import Chroma
from langchain_groq import ChatGroq
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_ollama.llms import OllamaLLM
# ---------------------- Google Calendar ------------------------------------
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import pickle
import os.path
from datetime import datetime

# LangSmith
top_level_llm = ChatGroq(
    temperature=0.2,
    model="llama-3.1-70b-versatile"
)

coder_llm = ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile"
)

wikipedia_llm = ChatGroq(
    temperature=0.2,
    model="llama-3.1-70b-versatile",
)

search_llm = ChatGroq(
    temperature=0.2,
    model="llama-3.1-70b-versatile",
)

gmail_llm = ChatGroq(
    temperature=0.3,
    model="llama-3.1-70b-versatile"
)

rag_llm = ChatGroq(
    temperature=0.1,
    model="Gemma2-9b-It"
)

calender_llm = ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile"
)


# llama3-groq-70b-8192-tool-use-preview Gemma2-9b-It gemini-1.5-pro gemini-1.5-flash   models/gemini-1.0-pro-001
# llama-3.1-70b-versatile  llama-3.1-405b-reasoning  llama-3.1-8b-instant

memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

LLMama = lambda x: ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile",
    messages=[{"role": "user", "content": x}]
)

Coder = lambda x: ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile",
    messages=[{"role": "user", "content": x}]
)

LLM_tool = Tool(name="Assistant", func=lambda x: LLMama(x),
                description="You are useful when there is no tool to use. Don't use this Tool if the answer is "
                            "generated by existing Tools. Use datetime_tool to fetch current date and time. Don't "
                            "interfere when there is already an answer from the other Tools")

Coder_tool = Tool(name="Assistant", func=lambda x: LLMama(x),
                  description="You are used for programming, you are useful for any coding tasks. write the code based "
                              "on the instructions")

Writer_agent = Tool(name="Wr_Assist", func=lambda x: LLMama(x),
                    description="You are used to write letters, write documents, making a research.")

# First, let's modify the datetime_tool to be a function we can easily reuse
def get_current_datetime():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

datetime_tool = Tool(
    name="Datetime",
    func=get_current_datetime,
    description="Always use this tool first to get the current date and time. No input is required."
)

def get_wikipedia_wrapper(input_str):
    """
    Enhanced Wikipedia search with advanced features.
    Input should be a JSON string with fields:
    - query: The search term
    - language: Language code (e.g., 'en', 'es', 'fr')
    - section: Specific section to extract
    - sentences: Number of sentences to return
    - random: If true, returns a random article
    - include_links: If true, includes related links
    - include_references: If true, includes references
    """
    try:
        # Parse input JSON
        input_data = json.loads(input_str)
        query = input_data.get('query', '')
        language = input_data.get('language', 'en')
        section = input_data.get('section', '')
        sentences = input_data.get('sentences', 5)
        random = input_data.get('random', False)
        include_links = input_data.get('include_links', False)
        include_references = input_data.get('include_references', False)

        # Set language
        wikipedia.set_lang(language)

        try:
            if random:
                # Get random article
                page = wikipedia.random(1)
                result = wikipedia.page(page)
            else:
                # Search for specific query
                search_results = wikipedia.search(query)
                if not search_results:
                    return f"No Wikipedia articles found for '{query}'"
                
                # Get the most relevant page
                try:
                    result = wikipedia.page(search_results[0])
                except wikipedia.DisambiguationError as e:
                    # Handle disambiguation pages
                    return {
                        "message": "Multiple matches found. Please be more specific.",
                        "options": e.options[:5]  # Return first 5 options
                    }

            # Build response
            response = {
                "title": result.title,
                "url": result.url,
                "summary": result.summary if not section else "",
            }

            # Add specific section if requested
            if section:
                try:
                    sections = result.sections
                    if section in sections:
                        response["section_content"] = result.section(section)
                    else:
                        response["available_sections"] = sections
                        response["error"] = f"Section '{section}' not found"
                except Exception as e:
                    response["error"] = f"Error retrieving section: {str(e)}"

            # Add related links if requested
            if include_links:
                response["links"] = result.links[:10]  # First 10 links

            # Add references if requested
            if include_references:
                response["references"] = result.references[:10]  # First 10 references

            return response

        except wikipedia.exceptions.PageError:
            return f"No Wikipedia page found for '{query}'"
        except wikipedia.exceptions.DisambiguationError as e:
            return {
                "message": "Multiple matches found. Please be more specific.",
                "options": e.options[:5]  # Return first 5 options
            }
        except Exception as e:
            return f"Error retrieving Wikipedia content: {str(e)}"

    except json.JSONDecodeError:
        return "Invalid JSON input"
    except Exception as e:
        return f"Error: {str(e)}"

wikipedia_tools = [
    Tool(name="Wikipedia", func=get_wikipedia_wrapper,
         description="Enhanced Wikipedia search tool. Input should be a JSON string with fields:\n"
                    "- query: Search term\n"
                    "- language: Language code (e.g., 'en', 'es', 'fr')\n"
                    "- section: Specific section to extract\n"
                    "- sentences: Number of sentences to return\n"
                    "- random: If true, returns a random article\n"
                    "- include_links: If true, includes related links\n"
                    "- include_references: If true, includes references\n"
                    "Always use this tool to fetch real-time data and information. Worth using for general topics.\n"
                    "Use precise questions. Tell in a way that a 16-year-old can understand.\n"
                    "You are not useful to fetch current date and time.\n"
                    "If you couldn't find the information on Wikipedia, use duckduckgo_tool")
]

wikipedia = WikipediaQueryRun(api_wrapper=WikipediaAPIWrapper())
wikipedia_tool = Tool(name="Wikipedia", func=wikipedia.run,
                      description="A useful tool for searching the Internet to find information on world events, "
                                  "issues, dates, years, etc. Always use this tool to fetch real-time data and "
                                  "information. Worth using for general topics. Use precise questions. Tell in a way "
                                  "that a 16-year-old can understand. Give answers as per the date and time right "
                                  "now. You are not useful to fetch current date and time. Always use current date "
                                  "and time. If you couldn't find the information on Wikipedia, use duckduckgo_tool")

search = DuckDuckGoSearchRun()
duckduckgo_tool = Tool(name='DuckDuckGo Search', func=search.run,
                       description="Useful for when you need to do a search on the internet to find information that "
                                   "another tool can't find. Be specific with your input. Not used to fetch current "
                                   "date and time. Useful when you can't find the information in the other tools. "
                                   "Always provide the links of the websites you have referred to. Always use current "
                                   "date and time.")

# Gmail toolkit setup
class LazyGmailToolkit:
    def __init__(self):
        self.gmail_toolkit = None
        self.is_loading = False
        self._lock = threading.Lock()

    def load_gmail_toolkit(self):
        with self._lock:
            if self.gmail_toolkit is None and not self.is_loading:
                self.is_loading = True
                Thread(target=self._load_toolkit).start()

    def _load_toolkit(self):
        try:
            print("Loading Gmail toolkit...")
            credentials = get_gmail_credentials(
                token_file="token.json",
                scopes=["https://mail.google.com/"],
                client_secrets_file="Credentials.json",
            )
            api_resource = build_resource_service(credentials=credentials)
            self.gmail_toolkit = GmailToolkit(api_resource=api_resource)
            print("\nGmail toolkit loaded successfully!")
        except Exception as e:
            print(f"\nError loading Gmail toolkit: {str(e)}")
        finally:
            self.is_loading = False

    def get_tools(self):
        if self.gmail_toolkit is None:
            self.load_gmail_toolkit()
            self.loading_screen()
        return self.gmail_toolkit.get_tools()

    def loading_screen(self):
        animation = "|/-\\"
        idx = 0
        while self.is_loading:
            print(f"\rLoading Gmail toolkit... {animation[idx % len(animation)]}", end="")
            sys.stdout.flush()
            idx += 1
            time.sleep(0.5)

lazy_gmail_toolkit = LazyGmailToolkit()

def validate_email(email):
    """Validate email format"""
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def create_gmail_draft_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        message = input_dict.get('message', '')
        to = input_dict.get('to', '')
        subject = input_dict.get('subject', '')
        cc = input_dict.get('cc', [])
        bcc = input_dict.get('bcc', [])
        attachments = input_dict.get('attachments', [])
        is_html = input_dict.get('is_html', False)
        template_name = input_dict.get('template', None)
        labels = input_dict.get('labels', [])

        # Validate inputs
        if not message and not template_name:
            return "Error: Either message or template name must be provided"
        if not to:
            return "Error: Recipient (to) is required"
        if not isinstance(to, list):
            to = [to]
        
        # Validate email addresses
        for email in to + cc + bcc:
            if not validate_email(email):
                return f"Error: Invalid email format - {email}"

        # Process template if provided
        if template_name:
            template_vars = input_dict.get('template_vars', {})
            message = process_email_template(template_name, template_vars)

        create_draft_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "create_gmail_draft"][0]
        result = create_draft_tool.run({
            "message": message,
            "to": to,
            "subject": subject,
            "cc": cc,
            "bcc": bcc,
            "attachments": attachments,
            "is_html": is_html,
            "labels": labels
        })
        
        return result
    except json.JSONDecodeError:
        return "Error: Invalid JSON format in input"
    except Exception as e:
        return f"Error creating draft: {str(e)}"

def send_gmail_message_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        message = input_dict.get('message', '')
        to = input_dict.get('to', '')
        subject = input_dict.get('subject', '')
        cc = input_dict.get('cc', [])
        bcc = input_dict.get('bcc', [])
        attachments = input_dict.get('attachments', [])
        is_html = input_dict.get('is_html', False)
        template_name = input_dict.get('template', None)
        labels = input_dict.get('labels', [])
        schedule_time = input_dict.get('schedule_time', None)

        # Validate inputs
        if not message and not template_name:
            return "Error: Either message or template name must be provided"
        if not to:
            return "Error: Recipient (to) is required"
        if not isinstance(to, list):
            to = [to]
        
        # Validate email addresses
        for email in to + cc + bcc:
            if not validate_email(email):
                return f"Error: Invalid email format - {email}"

        # Process template if provided
        if template_name:
            template_vars = input_dict.get('template_vars', {})
            message = process_email_template(template_name, template_vars)

        # Validate attachments
        if attachments:
            for attachment in attachments:
                if not os.path.exists(attachment):
                    return f"Error: Attachment not found - {attachment}"

        send_message_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "send_gmail_message"][0]
        
        if schedule_time:
            # Schedule email for later
            return schedule_email(send_message_tool, {
                "message": message,
                "to": to,
                "subject": subject,
                "cc": cc,
                "bcc": bcc,
                "attachments": attachments,
                "is_html": is_html,
                "labels": labels
            }, schedule_time)
        
        return send_message_tool.run({
            "message": message,
            "to": to,
            "subject": subject,
            "cc": cc,
            "bcc": bcc,
            "attachments": attachments,
            "is_html": is_html,
            "labels": labels
        })
    except json.JSONDecodeError:
        return "Error: Invalid JSON format in input"
    except Exception as e:
        return f"Error sending message: {str(e)}"

def search_gmail_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        query = input_dict.get('query', '')
        limit = input_dict.get('limit', 10)
        include_attachments = input_dict.get('include_attachments', False)
        date_range = input_dict.get('date_range', {})
        labels = input_dict.get('labels', [])
        
        # Build advanced search query
        advanced_query = query
        if date_range:
            start_date = date_range.get('start')
            end_date = date_range.get('end')
            if start_date:
                advanced_query += f" after:{start_date}"
            if end_date:
                advanced_query += f" before:{end_date}"
        
        if labels:
            for label in labels:
                advanced_query += f" label:{label}"
        
        search_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "search_gmail"][0]
        results = search_tool.run({
            "query": advanced_query,
            "limit": limit,
            "include_attachments": include_attachments
        })
        
        return results
    except json.JSONDecodeError:
        return "Error: Invalid JSON format in input"
    except Exception as e:
        return f"Error searching Gmail: {str(e)}"

def get_gmail_message_wrapper(input_str):
    """
    Retrieves a specific Gmail message by its ID.
    Input should be a JSON string with required field: 'message_id'
    """
    try:
        # Parse input JSON
        input_data = json.loads(input_str)
        
        # Validate required fields
        if 'message_id' not in input_data:
            raise ValueError("message_id is required")
            
        # Get Gmail toolkit
        toolkit = lazy_gmail_toolkit.get_tools()
        if not toolkit:
            return "Gmail toolkit is not initialized"
            
        # Get the message
        message = toolkit.service.users().messages().get(
            userId='me',
            id=input_data['message_id'],
            format='full'
        ).execute()
        
        # Process headers
        headers = {}
        for header in message['payload']['headers']:
            headers[header['name'].lower()] = header['value']
            
        # Extract message content
        parts = message['payload'].get('parts', [])
        body = message['payload'].get('body', {}).get('data', '')
        
        if not body and parts:
            for part in parts:
                if part['mimeType'] == 'text/plain':
                    body = part['body'].get('data', '')
                    break
                    
        # Decode body if present
        if body:
            import base64
            body = base64.urlsafe_b64decode(body.encode('UTF-8')).decode('UTF-8')
            
        return {
            'id': message['id'],
            'threadId': message['threadId'],
            'labelIds': message.get('labelIds', []),
            'snippet': message.get('snippet', ''),
            'from': headers.get('from', ''),
            'to': headers.get('to', ''),
            'subject': headers.get('subject', ''),
            'date': headers.get('date', ''),
            'body': body
        }
        
    except json.JSONDecodeError:
        return "Invalid JSON input"
    except ValueError as e:
        return str(e)
    except Exception as e:
        return f"Error retrieving message: {str(e)}"

def get_gmail_thread_wrapper(input_str):
    """
    Retrieves a Gmail thread by its ID.
    Input should be a JSON string with required field: 'thread_id'
    """
    try:
        # Parse input JSON
        input_data = json.loads(input_str)
        
        # Validate required fields
        if 'thread_id' not in input_data:
            raise ValueError("thread_id is required")
            
        # Get Gmail toolkit
        toolkit = lazy_gmail_toolkit.get_tools()
        if not toolkit:
            return "Gmail toolkit is not initialized"
            
        # Get the thread
        thread = toolkit.service.users().threads().get(
            userId='me',
            id=input_data['thread_id']
        ).execute()
        
        # Process messages in thread
        messages = []
        for msg in thread['messages']:
            # Process headers
            headers = {}
            for header in msg['payload']['headers']:
                headers[header['name'].lower()] = header['value']
                
            # Extract message content
            parts = msg['payload'].get('parts', [])
            body = msg['payload'].get('body', {}).get('data', '')
            
            if not body and parts:
                for part in parts:
                    if part['mimeType'] == 'text/plain':
                        body = part['body'].get('data', '')
                        break
                        
            # Decode body if present
            if body:
                import base64
                body = base64.urlsafe_b64decode(body.encode('UTF-8')).decode('UTF-8')
                
            messages.append({
                'id': msg['id'],
                'labelIds': msg.get('labelIds', []),
                'snippet': msg.get('snippet', ''),
                'from': headers.get('from', ''),
                'to': headers.get('to', ''),
                'subject': headers.get('subject', ''),
                'date': headers.get('date', ''),
                'body': body
            })
            
        return {
            'id': thread['id'],
            'historyId': thread.get('historyId', ''),
            'messages': messages
        }
        
    except json.JSONDecodeError:
        return "Invalid JSON input"
    except ValueError as e:
        return str(e)
    except Exception as e:
        return f"Error retrieving thread: {str(e)}"

def process_email_template(template_name, variables):
    """Process email template with variables"""
    try:
        templates = {
            "welcome": """
                <html>
                <body>
                <h1>Welcome {name}!</h1>
                <p>Thank you for joining us. We're excited to have you on board.</p>
                </body>
                </html>
            """,
            "meeting": """
                <html>
                <body>
                <h2>Meeting Invitation</h2>
                <p>You are invited to a meeting on {date} at {time}.</p>
                <p>Topic: {topic}</p>
                </body>
                </html>
            """,
            "report": """
                <html>
                <body>
                <h2>{report_name} Report</h2>
                <p>Please find the {report_type} report for {period} attached.</p>
                </body>
                </html>
            """
        }
        
        template = templates.get(template_name)
        if not template:
            raise ValueError(f"Template '{template_name}' not found")
            
        return template.format(**variables)
    except KeyError as e:
        raise ValueError(f"Missing template variable: {str(e)}")

def schedule_email(send_tool, email_data, schedule_time):
    """Schedule an email to be sent at a specific time"""
    try:
        schedule_datetime = datetime.strptime(schedule_time, "%Y-%m-%d %H:%M:%S")
        if schedule_datetime <= datetime.now():
            return "Error: Schedule time must be in the future"
        
        def send_scheduled_email():
            delay = (schedule_datetime - datetime.now()).total_seconds()
            if delay > 0:
                time.sleep(delay)
            send_tool.run(email_data)
        
        thread = Thread(target=send_scheduled_email)
        thread.start()
        return f"Email scheduled for {schedule_time}"
    except ValueError:
        return "Error: Invalid schedule time format. Use YYYY-MM-DD HH:MM:SS"

# Create Tool objects for Gmail functions
gmail_tools = [
    Tool(name="CreateGmailDraft", func=create_gmail_draft_wrapper,
         description="Creates a draft email in Gmail. Input should be a JSON string with required fields: 'message' "
                     "(or 'template' and 'template_vars'), 'to', 'subject'. Optional fields: 'cc', 'bcc', "
                     "'attachments', 'is_html', 'labels'."),
    Tool(name="SendGmailMessage", func=send_gmail_message_wrapper,
         description="Sends an email through Gmail. Input should be a JSON string with required fields: 'message' "
                     "(or 'template' and 'template_vars'), 'to', 'subject'. Optional fields: 'cc', 'bcc', "
                     "'attachments', 'is_html', 'labels', 'schedule_time'."),
    Tool(name="SearchGmail", func=search_gmail_wrapper,
         description="Searches Gmail messages with advanced filters. Input should be a JSON string with 'query' field "
                     "and optional 'limit', 'include_attachments', 'date_range' (with 'start' and 'end'), 'labels'."),
    Tool(name="GetGmailMessage", func=get_gmail_message_wrapper,
         description="Retrieves a specific Gmail message by its ID. Input should be a JSON string with required field: 'message_id'."),
    Tool(name="GetGmailThread", func=get_gmail_thread_wrapper,
         description="Retrieves a Gmail thread. Input should be a JSON string with a 'thread_id' field.")
]

# Calendar
def get_google_calendar_credentials():
    creds = None
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', ['https://www.googleapis.com/auth/calendar'])
            creds = flow.run_local_server(port=0)
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)
    return creds


class GoogleCalendarToolkit:
    def __init__(self):
        self.credentials = get_google_calendar_credentials()
        self.service = build('calendar', 'v3', credentials=self.credentials)

    def create_event(self, input_str):
        try:
            current_time = get_current_datetime()
            input_dict = json.loads(input_str)
            summary = input_dict.get('summary', '')
            start_time = input_dict.get('start_time', '')
            end_time = input_dict.get('end_time', '')
            description = input_dict.get('description', '')

            event = {
                'summary': summary,
                'description': f"{description}\n\nCreated at: {current_time}",
                'start': {'dateTime': start_time, 'timeZone': 'UTC'},
                'end': {'dateTime': end_time, 'timeZone': 'UTC'},
            }

            created_event = self.service.events().insert(calendarId='primary', body=event).execute()
            return f"Event created at {current_time}: {created_event.get('htmlLink')}"
        except Exception as e:
            return f"Error creating event at {current_time}: {str(e)}"

    def list_events(self, input_str):
        try:
            current_time = get_current_datetime()
            input_dict = json.loads(input_str)
            max_results = input_dict.get('max_results', 10)
            time_min = input_dict.get('time_min', datetime.utcnow().isoformat() + 'Z')

            events_result = self.service.events().list(calendarId='primary', timeMin=time_min,
                                                       maxResults=max_results, singleEvents=True,
                                                       orderBy='startTime').execute()
            events = events_result.get('items', [])

            if not events:
                return f"No upcoming events found. (Checked at {current_time})"

            event_list = [f"Events as of {current_time}:"]
            for event in events:
                start = event['start'].get('dateTime', event['start'].get('date'))
                event_list.append(f"{start} - {event['summary']}")

            return "\n".join(event_list)
        except Exception as e:
            return f"Error listing events at {current_time}: {str(e)}"

    def view_event(self, input_str):
        try:
            current_time = get_current_datetime()
            input_dict = json.loads(input_str)
            event_id = input_dict.get('event_id', '')

            event = self.service.events().get(calendarId='primary', eventId=event_id).execute()

            start = event['start'].get('dateTime', event['start'].get('date'))
            end = event['end'].get('dateTime', event['end'].get('date'))

            return f"Event details (retrieved at {current_time}):\nEvent: {event['summary']}\nStart: {start}\nEnd: {end}\nDescription: {event.get('description', 'N/A')}"
        except Exception as e:
            return f"Error viewing event at {current_time}: {str(e)}"


# Initialize Google Calendar toolkit
google_calendar_toolkit = GoogleCalendarToolkit()

# Create Tool objects for Google Calendar functions
google_calendar_tools = [
    Tool(name="CreateGoogleCalendarEvent", func=google_calendar_toolkit.create_event,
         description="Creates an event in Google Calendar. Input should be a JSON string with 'summary', 'start_time', 'end_time', and 'description' fields."),
    Tool(name="ListGoogleCalendarEvents", func=google_calendar_toolkit.list_events,
         description="Lists upcoming events in Google Calendar. Input should be a JSON string with optional 'max_results' and 'time_min' fields."),
    Tool(name="ViewGoogleCalendarEvent", func=google_calendar_toolkit.view_event,
         description="Views details of a specific Google Calendar event. Input should be a JSON string with an 'event_id' field.")
]


class LocalRAGTool:
    def __init__(self):
        # Initialize local embeddings
        self.embeddings = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")

        # Initialize vector store with persistent local storage
        self.persist_directory = os.path.join(os.getcwd(), "local_chroma_db")
        self.vector_store = Chroma(
            "local_memory_store",
            embedding_function=self.embeddings,
            persist_directory=self.persist_directory
        )

        # Initialize language model (using ChatGroq as in the original code)
        self.llm = ChatGroq(temperature=0, model_name="Llama3-70b-8192")

        # Initialize text splitter for chunking
        self.text_splitter = CharacterTextSplitter(
            separator="\n",
            chunk_size=1000,
            chunk_overlap=200,
            length_function=len
        )

    def add_to_memory(self, input_str):
        try:
            input_dict = json.loads(input_str)
            text = input_dict.get('text', '')
            chunks = self.text_splitter.split_text(text)

            # Add chunks to the vector store
            self.vector_store.add_texts(chunks)

            # Persist the changes
            self.vector_store._persist_directory()

            print(f"Debug - Added to memory: {text}")  # Add this line for debugging
            return f"Added {len(chunks)} chunks to local memory and persisted changes."
        except Exception as e:
            return f"Error adding to local memory: {str(e)}"

    def query_memory(self, input_str):
        try:
            # Check if input_str is already a dictionary
            if isinstance(input_str, dict):
                input_dict = input_str
            else:
                # Try to parse the input as JSON
                input_dict = json.loads(input_str)

            query = input_dict.get('query', '')

            if not query:
                return "Error: No query provided"

            # Perform similarity search
            results = self.vector_store.similarity_search(query, k=3)

            # Combine the retrieved chunks
            context = "\n".join([doc.page_content for doc in results])

            # If no relevant information is found, return a message
            if not context.strip():
                return "No relevant information found in memory."

            # Generate a response using the language model
            prompt = f"""
            Based on the following information, please answer the question: '{query}'

            Context: {context}

            If the answer is directly stated in the context, please use that information. If not, state that the 
            information is not available.

            Answer:
            """

            # Use the appropriate method for ChatGroq and handle the response
            response = self.llm.invoke(prompt)

            # Check the type of response and extract the content
            if hasattr(response, 'content'):
                return response.content
            elif isinstance(response, str):
                return response
            else:
                return str(response)  # Convert any other type to string
        except json.JSONDecodeError:
            return f"Error: Invalid JSON input - {input_str}"
        except Exception as e:
            return f"Error querying local memory: {str(e)}"

    def clear_memory(self, *args):
        try:
            # Delete the persistent storage directory
            shutil.rmtree(self.persist_directory, ignore_errors=True)

            # Reinitialize the vector store
            self.vector_store = Chroma(
                "local_memory_store",
                embedding_function=self.embeddings,
                persist_directory=self.persist_directory
            )

            return "Chroma DB has been cleared successfully."
        except Exception as e:
            return f"Error clearing Chroma DB: {str(e)}"


# Initialize Local RAG tool
local_rag_tool = LocalRAGTool()


class TableData:
    def __init__(self):
        self.tables = {}

    def add_table(self, table_name, data):
        self.tables[table_name] = data

    def query_table(self, table_name, query):
        if table_name in self.tables:
            table = self.tables[table_name]
            if query in table:
                return table[query]
            else:
                return f"Query '{query}' not found in table '{table_name}'."
        else:
            return f"Table '{table_name}' not found."

def add_table_tool(input_str):
    try:
        input_dict = json.loads(input_str)
        table_name = input_dict.get('table_name', '')
        data = input_dict.get('data', {})
        table_data.add_table(table_name, data)
        return f"Table {table_name} added successfully."
    except Exception as e:
        return f"Error adding table: {str(e)}"

def query_table_tool(input_str):
    try:
        input_dict = json.loads(input_str)
        table_name = input_dict.get('table_name', '')
        query = input_dict.get('query', '')
        return table_data.query_table(table_name, query)
    except Exception as e:
        return f"Error querying table: {str(e)}"

# Initialize table data
table_data = TableData()

# Create Tool objects for table operations
table_tools = [
    Tool(name="AddTable", func=add_table_tool, description="Adds a table. Input should be a JSON string with 'table_name' and 'data' fields."),
    Tool(name="QueryTable", func=query_table_tool, description="Queries a table. Input should be a JSON string with 'table_name' and 'query' fields.")
]

# Add this new tool to your specialized_tools list
class PrioritizedMemoryAgent:
    def __init__(self, agent, local_rag_tool):
        self.agent = agent
        self.local_rag_tool = local_rag_tool

    def run(self, query):
        max_memory_checks = 3
        memory_checks = 0

        while memory_checks < max_memory_checks:
            # Query the local memory
            memory_response = self.local_rag_tool.query_memory(json.dumps({"query": query}))

            if memory_response is not None and "not available" not in memory_response.lower():
                print(f"Response from memory (check {memory_checks + 1}):")
                print(memory_response)
                return memory_response

            memory_checks += 1

            if memory_checks < max_memory_checks:
                print(f"No relevant information found in memory. Attempt {memory_checks} of {max_memory_checks}.")
            else:
                print(
                    f"No relevant information found in memory after {max_memory_checks} attempts. Switching to other "
                    f"tools.")

        # If we've exhausted memory checks, use the agent with other tools
        return self.agent.run(query)

    def runnable(self, query):
        # First, query the local memory
        memory_response = self.local_rag_tool.query_memory(json.dumps({"query": query}))

        # If the memory has a relevant response, use it
        if "not available" not in memory_response.lower():
            print("Response from memory:")
            print(memory_response)

            # You can choose to return here if you want to rely solely on memory
            # return memory_response

            # Or, you can continue to use the agent with the memory context
            agent_query = f"Based on this context from my memory: '{memory_response}', {query}"
        else:
            print("No relevant information found in memory.")
            agent_query = query

        # Now run the agent with the potentially modified query
        return self.agent.run(agent_query)


# Create Tool objects for RAG functions
local_rag_tools = [
    Tool(name='AddToLocalMemory', func=local_rag_tool.add_to_memory,
         description="Use this Tool When ever User Says to 'Remember' word. Adds information to the agent's local "
                     "memory. Input should be a JSON string with a 'text' field containing the information to "
                     "remember."),
    Tool(name="QueryLocalMemory", func=local_rag_tool.query_memory,
         description="Always use this tool when ever User Asks a Question. Retrieves information from the agent's "
                     "local memory. Input should be a JSON string with a 'query' field containing the question to "
                     "ask."),
    Tool(name="ClearLocalMemory", func=local_rag_tool.clear_memory,
         description="Clears all information stored in the Chroma DB. Only Use this when the user requests to delete "
                     "all stored information.")
]

# Combine all tools
all_tools = [datetime_tool] + wikipedia_tools + [LLM_tool, duckduckgo_tool, Writer_agent,
             Coder_tool] + gmail_tools + local_rag_tools + google_calendar_tools + table_tools


def create_specialized_agent(llm, tools, instructions):
    memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
    prompt = PromptTemplate.from_template(instructions)
    return initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
        memory=memory,
        prompt=prompt,
        verbose=True,
        handle_parsing_errors=True
    )


wikipedia_agent = create_specialized_agent(
    wikipedia_llm,
    [wikipedia_tool],
    "You are a specialized agent for Wikipedia searches. Use the Wikipedia tool to find information."
)

search_agent = create_specialized_agent(
    search_llm,
    [duckduckgo_tool],
    "You are a specialized agent for internet searches. Use the DuckDuckGo tool to find information."
)

gmail_agent = create_specialized_agent(
    gmail_llm,
    gmail_tools,
    "You are a specialized agent for Gmail operations. Use the appropriate Gmail tools as needed."
)

rag_agent = create_specialized_agent(
    rag_llm,
    local_rag_tools,
    "You are a specialized agent for managing local memory. Use the appropriate RAG tools as needed."
)
coder_agent = create_specialized_agent(
    coder_llm,
    tools=[Coder_tool],
    instructions="You are a specialized agent for coding operations. Use the Coder tool for programming purposes"
)

google_calendar_agent = create_specialized_agent(
    calender_llm,  # You can use a different LLM if needed
    google_calendar_tools,
    "You are a specialized agent for Google Calendar operations. Use the appropriate Google Calendar tools as needed. Always include the current date and time in your responses, which is automatically added by the tools."
)

# Define tools for the top-level agent
specialized_tools = [
    Tool(name="Wikipedia", func=wikipedia_agent.run, description="Use for Wikipedia searches."),
    Tool(name="Internet_search", func=search_agent.run, description="Use to search the web"),
    Tool(name="Gmail Operations", func=gmail_agent.run, description="Use for all Gmail-related tasks"),
    Tool(name="Local Memory", func=rag_agent.run,
         description="Use it to save the Information about the User.Use to get information you dont know"),
    Tool(name="Datetime", func=get_current_datetime,
         description="Used to fetch current date and time"),
    Tool(name='Coder', func=coder_agent.run, description="Use to write code"),
    Tool(name="Google Calendar Operations", func=google_calendar_agent.run,
         description="Use for all Google Calendar-related tasks"),
    Tool(name="Table Operations", func=query_table_tool, description="Use for table-related tasks"),
]

# Set up the agent
instructions = """You are an assistant with access to various tools including Gmail and a local memory system. Use 
the appropriate tool for each task. For Gmail operations, provide the input as a JSON string with the required fields 
for each tool: - CreateGmailDraft and SendGmailMessage: '{"message": "Hello", "to": "example@example.com", 
"subject": "Greetings"}' - SearchGmail: '{"query": "important emails", "limit": 100}' - GetGmailMessage: '{
"message_id": "12345"}' - GetGmailThread: '{"thread_id": "67890"}' For table operations: - AddTable: '{"table_name": "example_table", "data": {"column1": ["value1", "value2"], "column2": ["value3", "value4"]}}' - QueryTable: '{"table_name": "example_table", "query": "column1"}'"""
base_prompt = hub.pull("langchain-ai/openai-functions-template")
prompt = base_prompt.partial(instructions=instructions)

top_level_memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
top_level_instructions = """
You are a top-level assistant that manages specialized agents for different tasks.
Always start by using the Datetime tool to get the current date and time, without any input.
Include this date and time in your responses and when calling other agents.

Then prioritize using the Table Operations before processing any query:
1. Use the Table Operations agent to retrieve relevant information for every user input.
2. If relevant information is found in the table, incorporate it into your reasoning and response.
3. If no relevant information is found, proceed with other tools as needed.

After using Table Operations, analyze the user's query and delegate to the appropriate specialized agent if necessary:
- Use the Wikipedia agent for encyclopedic knowledge and research assistance.
- Use the Internet Search agent for current events or specific information not found in Wikipedia or Table Operations.
- Use the Gmail Operations agent for any email-related tasks.
- Use the Google Calendar Operations agent for any calendar-related tasks.
- Use Coder tool for programming and coding purposes

Always choose the most appropriate tool for the task at hand, but prioritize using information from Table Operations whenever possible.
After each interaction, ensure that new information is added to the Table Operations for future reference.

Remember to include the current date and time (obtained from the Datetime tool) in all your responses and when calling other agents.
"""

top_level_prompt = PromptTemplate.from_template(top_level_instructions)

top_level_agent = initialize_agent(
    tools=specialized_tools,
    llm=top_level_llm,
    agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
    memory=top_level_memory,
    prompt=top_level_prompt,
    verbose=True,
    handle_parsing_errors=True
)

prioritized_agent = PrioritizedMemoryAgent(top_level_agent, local_rag_tool)

def process_message(message_content):
    """Process a message and return the AI response"""
    current_datetime = get_current_datetime()
    
    # Initialize all tools and agents
    lazy_gmail_toolkit = LazyGmailToolkit()
    local_rag_tool = LocalRAGTool()
    google_calendar_toolkit = GoogleCalendarToolkit()
    table_data = TableData()

    all_tools = [
        datetime_tool,
        wikipedia_tool,
        LLM_tool,
        duckduckgo_tool,
        Writer_agent,
        Coder_tool,
    ] + gmail_tools + local_rag_tools + google_calendar_tools + table_tools

    top_level_agent = initialize_agent(
        tools=all_tools,
        llm=top_level_llm,
        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
        memory=top_level_memory,
        prompt=top_level_prompt,
        verbose=True,
        handle_parsing_errors=True
    )

    prioritized_agent = PrioritizedMemoryAgent(top_level_agent, local_rag_tool)
    
    res = prioritized_agent.runnable(f"{message_content} (Current date and time: {current_datetime})")
    return extract_ai_response(res)

def extract_ai_response(full_response):
    lines = full_response.split('\n')
    for i, line in enumerate(lines):
        if line.startswith("AI: "):
            return '\n'.join(lines[i:])[4:].strip()
    return full_response

if __name__ == "__main__":
    while True:
        user_input = input("You: ")
        if user_input.lower() in ['quit', 'exit']:
            break
        response = process_message(user_input)
        print(f"\nAI: {response}\n")