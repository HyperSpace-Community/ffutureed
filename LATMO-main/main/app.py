# -------------------- System Libraries --------------------------------
import json
import os
import shutil
from threading import Thread
import sys
import streamlit as st
import json
# -------------------- Dynamic Libraries --------------------------------
from langchain import hub
from langchain.agents import AgentType, Tool, initialize_agent
from langchain.memory import ConversationBufferMemory
from langchain_huggingface import HuggingFaceEmbeddings
from langchain.text_splitter import CharacterTextSplitter
from langchain_community.agent_toolkits import GmailToolkit
from langchain_community.tools import WikipediaQueryRun, DuckDuckGoSearchRun
from langchain.prompts import PromptTemplate
from langchain_community.tools.gmail.utils import build_resource_service, get_gmail_credentials
from langchain_community.utilities import WikipediaAPIWrapper
from langchain_groq import ChatGroq
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_ollama.llms import OllamaLLM
# ---------------------- Google Calendar ------------------------------------
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import pickle
import os.path
from datetime import datetime
import time

# LangChain
top_level_llm = ChatGroq(
    temperature=0.2,
    model="Gemma2-9b-It"
)

coder_llm = ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile"
)

wikipedia_llm = ChatGoogleGenerativeAI(
    temperature=0.2,
    model="gemini-1.5-pro",
    description="Gather a lot of information"
)

search_llm = ChatGoogleGenerativeAI(
    temperature=0.2,
    model="gemini-1.5-pro",
    description="Gather a lot of information"
)

gmail_llm = ChatGoogleGenerativeAI(
    temperature=0.3,
    model="gemini-1.5-pro"
)

rag_llm = ChatGroq(
    temperature=0.1,
    model="Gemma2-9b-It"
)

calender_llm = ChatGoogleGenerativeAI(
    temperature=0,
    model="gemini-1.5-pro"
)


# llama3-groq-70b-8192-tool-use-preview Gemma2-9b-It gemini-1.5-pro gemini-1.5-flash   models/gemini-1.0-pro-001
# llama-3.1-70b-versatile  llama-3.1-405b-reasoning  llama-3.1-8b-instant

memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

LLMama = lambda x: ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile",
    messages=[{"role": "user", "content": x}]
)

Coder = lambda x: ChatGroq(
    temperature=0,
    model="llama-3.1-70b-versatile",
    messages=[{"role": "user", "content": x}]
)

LLM_tool = Tool(name="Assistant", func=lambda x: LLMama(x),
                description="You are useful when there is no tool to use. Don't use this Tool if the answer is "
                            "generated by existing Tools. Use datetime_tool to fetch current date and time. Don't "
                            "interfere when there is already an answer from the other Tools")

Coder_tool = Tool(name="Assistant", func=lambda x: LLMama(x),
                  description="You are used for programming, you are useful for any coding tasks. write the code based "
                              "on the instructions")

Writer_agent = Tool(name="Wr_Assist", func=lambda x: LLMama(x),
                    description="You are used to write letters, write documents, making a research.")

# First, let's modify the datetime_tool to be a function we can easily reuse
def get_current_datetime():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

datetime_tool = Tool(
    name="Datetime",
    func=get_current_datetime,
    description="Always use this tool first to get the current date and time. No input is required."
)

wikipedia = WikipediaQueryRun(api_wrapper=WikipediaAPIWrapper())
wikipedia_tool = Tool(name="Wikipedia", func=wikipedia.run,
                      description="A useful tool for searching the Internet to find information on world events, "
                                  "issues, dates, years, etc. Always use this tool to fetch real-time data and "
                                  "information. Worth using for general topics. Use precise questions. Tell in a way "
                                  "that a 16-year-old can understand. Give answers as per the date and time right "
                                  "now. You are not useful to fetch current date and time. Always use current date "
                                  "and time. If you couldn't find the information on Wikipedia, use duckduckgo_tool")

search = DuckDuckGoSearchRun()
duckduckgo_tool = Tool(name='DuckDuckGo Search', func=search.run,
                       description="Useful for when you need to do a search on the internet to find information that "
                                   "another tool can't find. Be specific with your input. Not used to fetch current "
                                   "date and time. Useful when you can't find the information in the other tools. "
                                   "Always provide the links of the websites you have referred to. Always use current "
                                   "date and time.")

# Gmail toolkit setup
credentials = get_gmail_credentials(
    token_file="token.json",
    scopes=["https://mail.google.com/"],
    client_secrets_file="credentials.json",
)
api_resource = build_resource_service(credentials=credentials)
gmail_toolkit = GmailToolkit(api_resource=api_resource)


# Wrapper functions for Gmail tools


class LazyGmailToolkit:
    def __init__(self):
        self.gmail_toolkit = None
        self.is_loading = False

    def load_gmail_toolkit(self):
        if self.gmail_toolkit is None and not self.is_loading:
            self.is_loading = True
            Thread(target=self._load_toolkit).start()

    def _load_toolkit(self):
        print("Loading Gmail toolkit...")
        credentials = get_gmail_credentials(
            token_file="token.json",
            scopes=["https://mail.google.com/"],
            client_secrets_file="Credentials.json",
        )
        api_resource = build_resource_service(credentials=credentials)
        self.gmail_toolkit = GmailToolkit(api_resource=api_resource)
        self.is_loading = False
        print("\nGmail toolkit loaded successfully!")

    def get_tools(self):
        if self.gmail_toolkit is None:
            self.load_gmail_toolkit()
            self.loading_screen()
        return self.gmail_toolkit.get_tools()

    def loading_screen(self):
        animation = "|/-\\"
        idx = 0
        while self.is_loading:
            print(f"\rLoading Gmail toolkit... {animation[idx % len(animation)]}", end="")
            sys.stdout.flush()
            idx += 1
            time.sleep(0.5)


lazy_gmail_toolkit = LazyGmailToolkit()


# Modify wrapper functions to use lazy_gmail_toolkit
def create_gmail_draft_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        message = input_dict.get('message', '')
        to = input_dict.get('to', '')
        subject = input_dict.get('subject', '')
        create_draft_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "create_gmail_draft"][0]
        return create_draft_tool.run({"message": message, "to": to, "subject": subject})
    except Exception as e:
        return f"Error creating draft: {str(e)}"


def send_gmail_message_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        message = input_dict.get('message', '')
        to = input_dict.get('to', '')
        subject = input_dict.get('subject', '')
        send_message_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "send_gmail_message"][0]
        return send_message_tool.run({"message": message, "to": to, "subject": subject})
    except Exception as e:
        return f"Error sending message: {str(e)}"


def search_gmail_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        query = input_dict.get('query', '')
        limit = input_dict.get('limit', 10)
        search_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "search_gmail"][0]
        return search_tool.run({"query": query, "limit": limit})
    except Exception as e:
        return f"Error searching Gmail: {str(e)}"


def get_gmail_message_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        message_id = input_dict.get('message_id', '')
        get_message_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "get_gmail_message"][0]
        return get_message_tool.run({"message_id": message_id})
    except Exception as e:
        return f"Error getting message: {str(e)}"


def get_gmail_thread_wrapper(input_str):
    try:
        input_dict = json.loads(input_str)
        thread_id = input_dict.get('thread_id', '')
        get_thread_tool = [tool for tool in lazy_gmail_toolkit.get_tools() if tool.name == "get_gmail_thread"][0]
        return get_thread_tool.run({"thread_id": thread_id})
    except Exception as e:
        return f"Error getting thread: {str(e)}"


# Create Tool objects for Gmail functions (unchanged)
gmail_tools = [
    Tool(name="CreateGmailDraft", func=create_gmail_draft_wrapper,
         description="Creates a draft email in Gmail. Input should be a JSON string with 'message', 'to', "
                     "and 'subject' fields."),
    Tool(name="SendGmailMessage", func=send_gmail_message_wrapper,
         description="Sends an email through Gmail. Input should be a JSON string with 'message', 'to', and 'subject' "
                     "fields."),
    Tool(name="SearchGmail", func=search_gmail_wrapper, description="Searches Gmail messages. Input should be a JSON "
                                                                    "string with 'query' and optionally 'limit' "
                                                                    "fields."),
    Tool(name="GetGmailMessage", func=get_gmail_message_wrapper,
         description="Retrieves a specific Gmail message. Input should be a JSON string with a 'message_id' field."),
    Tool(name="GetGmailThread", func=get_gmail_thread_wrapper,
         description="Retrieves a Gmail thread. Input should be a JSON string with a 'thread_id' field.")
]


# Calendar
def get_google_calendar_credentials():
    creds = None
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', ['https://www.googleapis.com/auth/calendar'])
            creds = flow.run_local_server(port=0)
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)
    return creds


class GoogleCalendarToolkit:
    def __init__(self):
        self.credentials = get_google_calendar_credentials()
        self.service = build('calendar', 'v3', credentials=self.credentials)

    def create_event(self, input_str):
        try:
            current_time = get_current_datetime()
            input_dict = json.loads(input_str)
            summary = input_dict.get('summary', '')
            start_time = input_dict.get('start_time', '')
            end_time = input_dict.get('end_time', '')
            description = input_dict.get('description', '')

            event = {
                'summary': summary,
                'description': f"{description}\n\nCreated at: {current_time}",
                'start': {'dateTime': start_time, 'timeZone': 'UTC'},
                'end': {'dateTime': end_time, 'timeZone': 'UTC'},
            }

            created_event = self.service.events().insert(calendarId='primary', body=event).execute()
            return f"Event created at {current_time}: {created_event.get('htmlLink')}"
        except Exception as e:
            return f"Error creating event at {current_time}: {str(e)}"

    def list_events(self, input_str):
        try:
            current_time = get_current_datetime()
            input_dict = json.loads(input_str)
            max_results = input_dict.get('max_results', 10)
            time_min = input_dict.get('time_min', datetime.utcnow().isoformat() + 'Z')

            events_result = self.service.events().list(calendarId='primary', timeMin=time_min,
                                                       maxResults=max_results, singleEvents=True,
                                                       orderBy='startTime').execute()
            events = events_result.get('items', [])

            if not events:
                return f"No upcoming events found. (Checked at {current_time})"

            event_list = [f"Events as of {current_time}:"]
            for event in events:
                start = event['start'].get('dateTime', event['start'].get('date'))
                event_list.append(f"{start} - {event['summary']}")

            return "\n".join(event_list)
        except Exception as e:
            return f"Error listing events at {current_time}: {str(e)}"

    def view_event(self, input_str):
        try:
            current_time = get_current_datetime()
            input_dict = json.loads(input_str)
            event_id = input_dict.get('event_id', '')

            event = self.service.events().get(calendarId='primary', eventId=event_id).execute()

            start = event['start'].get('dateTime', event['start'].get('date'))
            end = event['end'].get('dateTime', event['end'].get('date'))

            return f"Event details (retrieved at {current_time}):\nEvent: {event['summary']}\nStart: {start}\nEnd: {end}\nDescription: {event.get('description', 'N/A')}"
        except Exception as e:
            return f"Error viewing event at {current_time}: {str(e)}"


# Initialize Google Calendar toolkit
google_calendar_toolkit = GoogleCalendarToolkit()

# Create Tool objects for Google Calendar functions
google_calendar_tools = [
    Tool(name="CreateGoogleCalendarEvent", func=google_calendar_toolkit.create_event,
         description="Creates an event in Google Calendar. Input should be a JSON string with 'summary', 'start_time', 'end_time', and 'description' fields."),
    Tool(name="ListGoogleCalendarEvents", func=google_calendar_toolkit.list_events,
         description="Lists upcoming events in Google Calendar. Input should be a JSON string with optional 'max_results' and 'time_min' fields."),
    Tool(name="ViewGoogleCalendarEvent", func=google_calendar_toolkit.view_event,
         description="Views details of a specific Google Calendar event. Input should be a JSON string with an 'event_id' field.")
]


class LocalRAGTool:
    def __init__(self):
        # Initialize local embeddings
        self.embeddings = HuggingFaceEmbeddings(model_name="all-MiniLM-L6-v2")
        
        # Remove Chroma vector store initialization
        # self.persist_directory = os.path.join(os.getcwd(), "local_chroma_db")
        # self.vector_store = Chroma(
        #     "local_memory_store",
        #     embedding_function=self.embeddings,
        #     persist_directory=self.persist_directory
        # )
        
        # You may want to replace Chroma with another vector store or remove vector store functionality
        self.vector_store = None
        
        # Initialize language model (using ChatGroq as in the original code)
        self.llm = ChatGroq(temperature=0, model_name="Llama3-70b-8192")
        
        # Initialize text splitter for chunking
        self.text_splitter = CharacterTextSplitter(
            separator="\n",
            chunk_size=1000,
            chunk_overlap=200,
            length_function=len
        )
    
    # Modify methods to handle the absence of Chroma vector store
    def add_to_memory(self, input_str):
        # Implement alternative memory storage or remove functionality
        print(f"Adding to memory: {input_str}")
        return "Memory addition not implemented"
    
    def query_memory(self, input_str):
        # Implement alternative memory querying or remove functionality
        print(f"Querying memory: {input_str}")
        return "Memory query not implemented"
    
    def clear_memory(self, *args):
        # Implement alternative memory clearing or remove functionality
        print("Clearing memory")
        return "Memory clearing not implemented"


# Initialize Local RAG tool
local_rag_tool = LocalRAGTool()


class TableData:
    def __init__(self):
        self.tables = {}

    def add_table(self, table_name, data):
        self.tables[table_name] = data

    def query_table(self, table_name, query):
        if table_name in self.tables:
            table = self.tables[table_name]
            if query in table:
                return table[query]
            else:
                return f"Query '{query}' not found in table '{table_name}'."
        else:
            return f"Table '{table_name}' not found."

def add_table_tool(input_str):
    try:
        input_dict = json.loads(input_str)
        table_name = input_dict.get('table_name', '')
        data = input_dict.get('data', {})
        table_data.add_table(table_name, data)
        return f"Table {table_name} added successfully."
    except Exception as e:
        return f"Error adding table: {str(e)}"

def query_table_tool(input_str):
    try:
        input_dict = json.loads(input_str)
        table_name = input_dict.get('table_name', '')
        query = input_dict.get('query', '')
        return table_data.query_table(table_name, query)
    except Exception as e:
        return f"Error querying table: {str(e)}"

# Initialize table data
table_data = TableData()

# Create Tool objects for table operations
table_tools = [
    Tool(name="AddTable", func=add_table_tool, description="Adds a table. Input should be a JSON string with 'table_name' and 'data' fields."),
    Tool(name="QueryTable", func=query_table_tool, description="Queries a table. Input should be a JSON string with 'table_name' and 'query' fields.")
]

# Add this new tool to your specialized_tools list
class PrioritizedMemoryAgent:
    def __init__(self, agent, local_rag_tool):
        self.agent = agent
        self.local_rag_tool = local_rag_tool

    def run(self, query):
        max_memory_checks = 3
        memory_checks = 0

        while memory_checks < max_memory_checks:
            # Query the local memory
            memory_response = self.local_rag_tool.query_memory(json.dumps({"query": query}))

            if memory_response is not None and "not available" not in memory_response.lower():
                print(f"Response from memory (check {memory_checks + 1}):")
                print(memory_response)
                return memory_response

            memory_checks += 1

            if memory_checks < max_memory_checks:
                print(f"No relevant information found in memory. Attempt {memory_checks} of {max_memory_checks}.")
            else:
                print(
                    f"No relevant information found in memory after {max_memory_checks} attempts. Switching to other "
                    f"tools.")

        # If we've exhausted memory checks, use the agent with other tools
        return self.agent.run(query)

    def runnable(self, query):
        # First, query the local memory
        memory_response = self.local_rag_tool.query_memory(json.dumps({"query": query}))

        # If the memory has a relevant response, use it
        if "not available" not in memory_response.lower():
            print("Response from memory:")
            print(memory_response)

            # You can choose to return here if you want to rely solely on memory
            # return memory_response

            # Or, you can continue to use the agent with the memory context
            agent_query = f"Based on this context from my memory: '{memory_response}', {query}"
        else:
            print("No relevant information found in memory.")
            agent_query = query

        # Now run the agent with the potentially modified query
        return self.agent.run(agent_query)


# Create Tool objects for RAG functions
local_rag_tools = [
    Tool(name='AddToLocalMemory', func=local_rag_tool.add_to_memory,
         description="Use this Tool When ever User Says to 'Remember' word. Adds information to the agent's local "
                     "memory. Input should be a JSON string with a 'text' field containing the information to "
                     "remember."),
    Tool(name="QueryLocalMemory", func=local_rag_tool.query_memory,
         description="Always use this tool when ever User Asks a Question. Retrieves information from the agent's "
                     "local memory. Input should be a JSON string with a 'query' field containing the question to "
                     "ask."),
    Tool(name="ClearLocalMemory", func=local_rag_tool.clear_memory,
         description="Clears all information stored in the Chroma DB. Only Use this when the user requests to delete "
                     "all stored information.")
]

# Notepad operations

import win32gui
import win32com.client
import time
import json
import os

def write_to_notepad(input_str):
    try:
        input_dict = json.loads(input_str)
        text = input_dict.get('text', '')
        
        if not text.strip():
            return "Error: No text to write."

        # Start Notepad
        shell = win32com.client.Dispatch("WScript.Shell")
        shell.Run("notepad.exe")
        time.sleep(1)  # Wait for Notepad to start

        # Find the Notepad window
        notepad_handle = win32gui.FindWindow(None, "Untitled - Notepad")
        if notepad_handle == 0:
            return "Error: Could not find Notepad window."

        # Activate Notepad window
        win32gui.SetForegroundWindow(notepad_handle)
        time.sleep(0.5)

        # Type the text
        for char in text:
            if char == '\n':
                shell.SendKeys('{ENTER}')
            else:
                shell.SendKeys(char)
            time.sleep(0.01)  # Small delay between characters

        time.sleep(1)  # Wait for typing to complete

        return f"Text written to Notepad: {text[:50]}..."  # Return first 50 characters as confirmation
    except Exception as e:
        return f"Error writing to Notepad: {str(e)}"

def save_notepad_file(input_str):
    try:
        input_dict = json.loads(input_str)
        file_path = input_dict.get('file_path', 'output.txt')
        
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Find the Notepad window
        notepad_handle = win32gui.FindWindow(None, "Untitled - Notepad")
        if notepad_handle == 0:
            return "Error: Could not find Notepad window."

        # Activate Notepad window
        win32gui.SetForegroundWindow(notepad_handle)
        time.sleep(0.5)

        # Perform save operation
        shell = win32com.client.Dispatch("WScript.Shell")
        shell.SendKeys('^s')  # Ctrl+S to open Save dialog
        time.sleep(1)
        shell.SendKeys(file_path)
        time.sleep(0.5)
        shell.SendKeys('{ENTER}')
        
        # Wait for the file to be saved
        for _ in range(20):  # Try for 20 seconds
            if os.path.exists(file_path):
                time.sleep(1)  # Give it a moment to finish writing
                return f"Notepad file saved as {file_path}."
            time.sleep(1)
        
        return "Error: File not saved within the expected time."
    except Exception as e:
        return f"Error saving Notepad file: {str(e)}"

def read_notepad_file(input_str):
    try:
        input_dict = json.loads(input_str)
        file_path = input_dict.get('file_path', 'output.txt')
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.read()
        return f"File contents: {content[:100]}..."  # Return first 100 characters
    except Exception as e:
        return f"Error reading Notepad file: {str(e)}"

# Create Tool objects for Notepad functions
notepad_tools = [
    Tool(name="WriteToNotepad", func=write_to_notepad, 
         description="Writes text to Notepad. Input should be a JSON string with a 'text' field."),
    Tool(name="SaveNotepadFile", func=save_notepad_file, 
         description="Saves the current Notepad file. Input should be a JSON string with a 'file_path' field."),
    Tool(name="ReadNotepadFile", func=read_notepad_file, 
         description="Reads a Notepad file. Input should be a JSON string with a 'file_path' field.")
]

# Combine all tools
all_tools = [datetime_tool, wikipedia_tool, LLM_tool, duckduckgo_tool, Writer_agent,
             Coder_tool] + gmail_tools + local_rag_tools + google_calendar_tools + table_tools + notepad_tools


def create_specialized_agent(llm, tools, instructions):
    memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
    prompt = PromptTemplate.from_template(instructions)
    return initialize_agent(
        tools=tools,
        llm=llm,
        agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
        memory=memory,
        prompt=prompt,
        verbose=True,
        handle_parsing_errors=True,
    )


wikipedia_agent = create_specialized_agent(
    wikipedia_llm,
    [wikipedia_tool],
    "You are a specialized agent for Wikipedia searches. Use the Wikipedia tool to find information."
)

search_agent = create_specialized_agent(
    search_llm,
    [duckduckgo_tool],
    "You are a specialized agent for internet searches. Use the DuckDuckGo tool to find information."
)

gmail_agent = create_specialized_agent(
    gmail_llm,
    gmail_tools,
    "You are a specialized agent for Gmail operations. Use the appropriate Gmail tools as needed."
)

rag_agent = create_specialized_agent(
    rag_llm,
    local_rag_tools,
    "You are a specialized agent for managing local memory. Use the appropriate RAG tools as needed."
)
coder_agent = create_specialized_agent(
    coder_llm,
    tools=[Coder_tool],
    instructions="You are a specialized agent for coding operations. Use the Coder tool for programming purposes"
)

google_calendar_agent = create_specialized_agent(
    calender_llm,  # You can use a different LLM if needed
    google_calendar_tools,
    "You are a specialized agent for Google Calendar operations. Use the appropriate Google Calendar tools as needed. Always include the current date and time in your responses, which is automatically added by the tools."
)

# Define tools for the top-level agent
specialized_tools = [
    Tool(name="Wikipedia", func=wikipedia_agent.run, description="Use for Wikipedia searches."),
    Tool(name="Internet_search", func=search_agent.run, description="Use to search the web"),
    Tool(name="Gmail Operations", func=gmail_agent.run, description="Use for all Gmail-related tasks"),
    Tool(name="Local Memory", func=rag_agent.run,
         description="Use it to save the Information about the User.Use to get information you dont know"),
    Tool(name="Datetime", func=get_current_datetime,
         description="Used to fetch current date and time"),
    Tool(name='Coder', func=coder_agent.run, description="Use to write code"),
    Tool(name="Google Calendar Operations", func=google_calendar_agent.run,
         description="Use for all Google Calendar-related tasks"),
    Tool(name="Table Operations", func=query_table_tool, description="Use for table-related tasks"),
]

# Set up the agent
instructions = """You are an assistant with access to various tools including Gmail and a local memory system. Use 
the appropriate tool for each task. For Gmail operations, provide the input as a JSON string with the required fields 
for each tool: - CreateGmailDraft and SendGmailMessage: '{"message": "Hello", "to": "example@example.com", 
"subject": "Greetings"}' - SearchGmail: '{"query": "important emails", "limit": 100}' - GetGmailMessage: '{
"message_id": "12345"}' - GetGmailThread: '{"thread_id": "67890"}' For table operations: - AddTable: '{"table_name": "example_table", "data": {"column1": ["value1", "value2"], "column2": ["value3", "value4"]}}' - QueryTable: '{"table_name": "example_table", "query": "column1"}'"""
base_prompt = hub.pull("langchain-ai/openai-functions-template")
prompt = base_prompt.partial(instructions=instructions)

top_level_memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)
top_level_instructions = """
You are a top-level assistant that manages specialized agents for different tasks.
Always start by using the Datetime tool to get the current date and time, without any input.
Include this date and time in your responses and when calling other agents.

Then prioritize using the Table Operations before processing any query:
1. Use the Table Operations agent to retrieve relevant information for every user input.
2. If relevant information is found in the table, incorporate it into your reasoning and response.
3. If no relevant information is found, proceed with other tools as needed.

After using Table Operations, analyze the user's query and delegate to the appropriate specialized agent if necessary:
- Use the Wikipedia agent for encyclopedic knowledge and research assistance.
- Use the Internet Search agent for current events or specific information not found in Wikipedia or Table Operations.
- Use the Gmail Operations agent for any email-related tasks.
- Use the Google Calendar Operations agent for any calendar-related tasks.
- Use Coder tool for programming and coding purposes

Always choose the most appropriate tool for the task at hand, but prioritize using information from Table Operations whenever possible.
After each interaction, ensure that new information is added to the Table Operations for future reference.

Remember to include the current date and time (obtained from the Datetime tool) in all your responses and when calling other agents.
"""

top_level_prompt = PromptTemplate.from_template(top_level_instructions)

top_level_agent = initialize_agent(
    tools=specialized_tools,
    llm=top_level_llm,
    agent=AgentType.CONVERSATIONAL_REACT_DESCRIPTION,
    memory=top_level_memory,
    prompt=top_level_prompt,
    verbose=True,
    handle_parsing_errors=True,
)

prioritized_agent = PrioritizedMemoryAgent(top_level_agent, local_rag_tool)

# Add this new function for Notepad operations

def streamlit_app():
    st.title("LATMO Multi-Agent AI Assistant")
    
    # Sidebar for agent selection
    st.sidebar.header("Agent Selection")
    agent_options = [
        "Top Level Agent", 
        "Coder Agent", 
        "Wikipedia Agent", 
        "Gmail Agent", 
        "Calendar Agent", 
        "Local RAG Agent", 
        "Notepad Agent"
    ]
    selected_agent = st.sidebar.selectbox("Choose an Agent", agent_options)
    
    # Input and interaction area
    st.header(f"{selected_agent} Interaction")
    
    # Agent-specific input and functionality
    user_input = st.text_area("Enter your query or instruction:", height=150)
    
    if st.button("Submit Query"):
        try:
            # Based on selected agent, route the query
            if selected_agent == "Top Level Agent":
                response = top_level_llm.invoke(user_input)
                st.success("Top Level Agent Response:")
                st.write(response.content)
            
            elif selected_agent == "Coder Agent":
                response = coder_llm.invoke(user_input)
                st.success("Coder Agent Response:")
                st.write(response.content)
            
            elif selected_agent == "Wikipedia Agent":
                wikipedia_tool = WikipediaQueryRun(api_wrapper=WikipediaAPIWrapper())
                response = wikipedia_tool.run(user_input)
                st.success("Wikipedia Agent Response:")
                st.write(response)
            
            elif selected_agent == "Gmail Agent":
                # Use lazy_gmail_toolkit to get tools
                gmail_tool_list = lazy_gmail_toolkit.get_tools()
                st.write("Gmail Tools Available:", [tool.name for tool in gmail_tool_list])
                # You might want to add more specific Gmail interactions here
            
            elif selected_agent == "Calendar Agent":
                calendar_tools = [
                    Tool(name="CreateEvent", func=google_calendar_toolkit.create_event, description="Create a Google Calendar event"),
                    Tool(name="ListEvents", func=google_calendar_toolkit.list_events, description="List Google Calendar events"),
                    Tool(name="ViewEvent", func=google_calendar_toolkit.view_event, description="View a specific Google Calendar event")
                ]
                st.write("Calendar Tools Available:", [tool.name for tool in calendar_tools])
            
            elif selected_agent == "Local RAG Agent":
                rag_response = local_rag_tool.query_memory(user_input)
                st.success("Local RAG Agent Response:")
                st.write(rag_response)
            
            elif selected_agent == "Notepad Agent":
                notepad_tools_names = [tool.name for tool in notepad_tools]
                st.write("Notepad Tools Available:", notepad_tools_names)
                
                # Add specific Notepad interactions
                notepad_action = st.selectbox("Choose Notepad Action", 
                    ["Write to Notepad", "Save Notepad File", "Read Notepad File"]
                )
                
                if notepad_action == "Write to Notepad":
                    write_to_notepad(json.dumps({"text": user_input}))
                    st.success("Text written to Notepad")
                
                elif notepad_action == "Save Notepad File":
                    save_notepad_file(user_input)
                    st.success("Notepad file saved")
                
                elif notepad_action == "Read Notepad File":
                    file_content = read_notepad_file(user_input)
                    st.success("Notepad File Content:")
                    st.write(file_content)
        
        except Exception as e:
            st.error(f"An error occurred: {str(e)}")
    
    # Additional information and help
    st.sidebar.markdown("### Help")
    st.sidebar.info(
        "Select an agent from the dropdown and enter your query. "
        "Each agent has different capabilities for various tasks."
    )

def main():
    streamlit_app()

def start():
    main()

if __name__ == "__main__":
    # Use Streamlit to run the app
    start()